/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.android.launcher3.folder

import android.animation.Animator
import android.animation.AnimatorListenerAdapter
import android.animation.AnimatorSet
import android.annotation.SuppressLint
import android.content.Context
import android.graphics.Rect
import android.text.InputType
import android.text.Selection
import android.util.AttributeSet
import android.util.Log
import android.util.Pair
import android.view.*
import android.view.View.OnFocusChangeListener
import android.view.View.OnLongClickListener
import android.view.ViewDebug.ExportedProperty
import android.view.ViewDebug.IntToString
import android.view.accessibility.AccessibilityEvent
import android.view.animation.AnimationUtils
import android.view.inputmethod.EditorInfo
import android.widget.TextView
import android.widget.TextView.OnEditorActionListener
import com.android.launcher3.*
import com.android.launcher3.DropTarget.DragObject
import com.android.launcher3.ExtendedEditText.OnBackKeyListener
import com.android.launcher3.FolderInfo.FolderListener
import com.android.launcher3.Workspace.ItemOperator
import com.android.launcher3.accessibility.AccessibleDragListenerAdapter
import com.android.launcher3.compat.AccessibilityManagerCompat
import com.android.launcher3.config.FeatureFlags
import com.android.launcher3.dragndrop.DragController
import com.android.launcher3.dragndrop.DragController.DragListener
import com.android.launcher3.dragndrop.DragLayer
import com.android.launcher3.dragndrop.DragOptions
import com.android.launcher3.logging.LoggerUtils.newContainerTarget
import com.android.launcher3.userevent.nano.LauncherLogProto
import com.android.launcher3.util.Thunk
import com.android.launcher3.views.BaseDragLayerLayoutParams
import com.android.launcher3.widget.PendingAddShortcutInfo
import kotlinx.android.synthetic.main.user_folder_icon_normalized.view.*
import java.util.*
import kotlin.math.max
import kotlin.math.min

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
open class Folder(context: Context, attrs: AttributeSet?) : AbstractFloatingView(context, attrs), DragSource, OnLongClickListener, DropTarget, FolderListener, OnEditorActionListener, OnFocusChangeListener, DragListener, OnBackKeyListener {
    private val reorderAlarm = Alarm()
    private val onExitAlarm = Alarm()
    private val onScrollHintAlarm = Alarm()

    @Thunk
    val scrollPauseAlarm = Alarm()

    @Thunk
    val itemsInReadingOrder = ArrayList<View>()
        get() {
            if (itemsInvalidated) {
                field.clear()
                content.iterateOverItems(ItemOperator { _, view ->
                    field.add(view)
                    false
                })
                itemsInvalidated = false
            }
            return field
        }
    private var currentAnimator: AnimatorSet? = null
    val launcher: Launcher
    lateinit var dragController: DragController

    /**
     * @return the FolderInfo object associated with this folder
     */
    lateinit var info: FolderInfo

    @Thunk
    lateinit var folderIcon: FolderIcon

    private var footerHeight = 0

    // Cell ranks used for drag and drop
    @Thunk
    var targetRank = 0

    @Thunk
    var prevTargetRank = 0

    @Thunk
    var emptyCellRank = 0

    @ExportedProperty(category = "launcher",
            mapping = [
                IntToString(from = STATE_NONE, to = "STATE_NONE"),
                IntToString(from = STATE_SMALL, to = "STATE_SMALL"),
                IntToString(from = STATE_ANIMATING, to = "STATE_ANIMATING"),
                IntToString(from = STATE_OPEN, to = "STATE_OPEN")
            ])
    @Thunk
    var state = STATE_NONE

    @ExportedProperty(category = "launcher")
    private var rearrangeOnClose = false
    private var itemsInvalidated = false
    private var currentDragView: View? = null
    private var isExternalDrag = false
    private var dragInProgress = false
    private var deleteFolderOnDropCompleted = false
    private var suppressFolderDeletion = false
    private var itemAddedBackToSelfViaIcon = false

    @Thunk
    var pivotXForIconAnimation = 0f

    @Thunk
    var pivotYForIconAnimation = 0f
    var isEditingName = false
        private set

    @ExportedProperty(category = "launcher")
    var isDestroyed = false
        private set

    // Folder scrolling
    private var scrollAreaOffset = 0

    @Thunk
    var scrollHintDir = SCROLL_NONE

    @Thunk
    var currentScrollDir = SCROLL_NONE


    private val onExitAlarmListener = OnAlarmListener { completeDragExit() }
    private val reorderAlarmListener = OnAlarmListener {
        content.realTimeReorder(emptyCellRank, targetRank)
        emptyCellRank = targetRank
    }
    val isLayoutRtl: Boolean
        get() = layoutDirection == LAYOUT_DIRECTION_RTL

    private val contentAreaHeight: Int
        get() {
            val grid = launcher.deviceProfile
            val maxContentAreaHeight = (grid.availableHeightPx
                    - grid.totalWorkspacePadding.y - footerHeight)
            val height = min(maxContentAreaHeight,
                    content.desiredHeight)
            return max(height, MIN_CONTENT_DIMEN)
        }
    private val contentAreaWidth: Int
        get() = max(content.desiredWidth, MIN_CONTENT_DIMEN)

    private val folderWidth: Int
        get() = paddingLeft + paddingRight + content.desiredWidth
    private val folderHeight: Int
        get() = getFolderHeight(contentAreaHeight)

    val itemCount: Int
        get() = content.itemCount

    init {
        isAlwaysDrawnWithCacheEnabled = false
        if (sDefaultFolderName == null) {
            sDefaultFolderName = resources.getString(R.string.folder_name)
        }
        if (sHintText == null) {
            sHintText = resources.getString(R.string.folder_hint_text)
        }
        launcher = Launcher.getLauncher(context)
        // We need this view to be focusable in touch mode so that when text editing of the folder
        // name is complete, we have something to focus on, thus hiding the cursor and giving
        // reliable behavior when clicking the text field (since it will always gain focus on click).
        isFocusableInTouchMode = true
    }

    override fun onFinishInflate() {
        super.onFinishInflate()
        content.setFolder(this)

        setupName()

        // We find out how tall footer wants to be (it is set to wrap_content), so that
        // we can allocate the appropriate amount of space for it.
        val measureSpec = MeasureSpec.UNSPECIFIED
        footer.measure(measureSpec, measureSpec)
        footerHeight = footer.measuredHeight
    }

    override fun onLongClick(v: View): Boolean {
        // Return if global dragging is not enabled
        return if (!launcher.isDraggingEnabled) true else startDrag(v, DragOptions())
    }

    fun startDrag(v: View, options: DragOptions): Boolean {
        val tag = v.tag
        if (tag is ShortcutInfo) {
            emptyCellRank = tag.rank
            currentDragView = v
            dragController.addDragListener(this)
            if (options.isAccessibleDrag) {
                dragController.addDragListener(object : AccessibleDragListenerAdapter(
                        content, CellLayout.FOLDER_ACCESSIBILITY_DRAG) {
                    override fun enableAccessibleDrag(enable: Boolean) {
                        super.enableAccessibleDrag(enable)
                        footer.importantForAccessibility = if (enable) IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS else IMPORTANT_FOR_ACCESSIBILITY_AUTO
                    }
                })
            }
            launcher.workspace.beginDragShared(v, this, options)
        }
        return true
    }

    override fun onDragStart(dragObject: DragObject, options: DragOptions) {
        if (dragObject.dragSource !== this) return
        content.removeItem(currentDragView)
        if (dragObject.dragInfo is ShortcutInfo) {
            itemsInvalidated = true
            SuppressInfoChanges().use { info.remove(dragObject.dragInfo as ShortcutInfo, true) }
        }
        dragInProgress = true
        itemAddedBackToSelfViaIcon = false
    }

    override fun onDragEnd() {
        if (isExternalDrag && dragInProgress) {
            completeDragExit()
        }
        dragInProgress = false
        dragController.removeDragListener(this)
    }

    private fun startEditingFolderName() {
        post {
            name.hint = ""
            isEditingName = true
        }
    }

    override fun onBackKey(): Boolean {
        // Convert to a string here to ensure that no other state associated with the text field
        // gets saved.
        val newTitle = name.text.toString()
        info.setTitle(newTitle)
        launcher.modelWriter.updateItemInDatabase(info)
        name.hint = if (sDefaultFolderName!!.contentEquals(newTitle)) sHintText else null
        AccessibilityManagerCompat.sendCustomAccessibilityEvent(
                this, AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                context.getString(R.string.folder_renamed, newTitle))

        // This ensures that focus is gained every time the field is clicked, which selects all
        // the text and brings up the soft keyboard if necessary.
        name.clearFocus()
        Selection.setSelection(name.text, 0, 0)
        isEditingName = false
        return true
    }

    override fun onEditorAction(v: TextView, actionId: Int, event: KeyEvent): Boolean {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            name.dispatchBackKey()
            return true
        }
        return false
    }

    override fun onAttachedToWindow() {
        // requestFocus() causes the focus onto the folder itself, which doesn't cause visual
        // effect but the next arrow key can start the keyboard focus inside of the folder, not
        // the folder itself.
        requestFocus()
        super.onAttachedToWindow()
    }

    override fun dispatchPopulateAccessibilityEvent(event: AccessibilityEvent): Boolean {
        // When the folder gets focus, we don't want to announce the list of items.
        return true
    }

    override fun focusSearch(direction: Int): View {
        // When the folder is focused, further focus search should be within the folder contents.
        return FocusFinder.getInstance().findNextFocus(this, null, direction)
    }

    fun bind(info: FolderInfo) {
        this.info = info
        val children = info.contents
        Collections.sort(children, ITEM_POS_COMPARATOR)
        content.bindItems(children)
        var lp = layoutParams as? BaseDragLayerLayoutParams
        if (lp == null) {
            lp = BaseDragLayerLayoutParams(0, 0)
            lp.customPosition = true
            layoutParams = lp
        }
        centerAboutIcon()
        itemsInvalidated = true
        updateTextViewFocus()
        info.addListener(this)
        if (!sDefaultFolderName!!.contentEquals(info.title)) {
            name.setText(info.title)
            name.hint = null
        } else {
            name.setText("")
            name.hint = sHintText
        }

        // In case any children didn't come across during loading, clean up the folder accordingly
        folderIcon.post {
            if (itemCount <= 1) {
                replaceFolderWithFinalItem()
            }
        }
    }

    private fun startAnimation(a: AnimatorSet) {
        if (currentAnimator != null && currentAnimator!!.isRunning) {
            currentAnimator!!.cancel()
        }
        a.addListener(object : AnimatorListenerAdapter() {
            override fun onAnimationStart(animation: Animator) {
                state = STATE_ANIMATING
                currentAnimator = a
            }

            override fun onAnimationEnd(animation: Animator) {
                currentAnimator = null
            }
        })
        a.start()
    }

    /**
     * Opens the user folder described by the specified tag. The opening of the folder
     * is animated relative to the specified View. If the View is null, no animation
     * is played.
     */
    fun animateOpen() {
        val openFolder = getOpen(launcher)
        if (openFolder != null && openFolder !== this) {
            // Close any open folder before opening a folder.
            openFolder.close(true)
        }
        isOpen = true
        val dragLayer = launcher.dragLayer
        // Just verify that the folder hasn't already been added to the DragLayer.
        // There was a one-off crash where the folder had a parent already.
        if (parent == null) {
            dragLayer.addView(this)
            dragController.addDropTarget(this)
        } else {
            if (FeatureFlags.IS_DOGFOOD_BUILD) {
                Log.e(TAG, "Opening folder ($this) which already has a parent:$parent")
            }
        }
        content.completePendingPageChanges()
        if (!dragInProgress) {
            // Open on the first page.
            content.snapToPageImmediately(0)
        }

        // This is set to true in close(), but isn't reset to false until onDropCompleted(). This
        // leads to an inconsistent state if you drag out of the folder and drag back in without
        // dropping. One resulting issue is that replaceFolderWithFinalItem() can be called twice.
        deleteFolderOnDropCompleted = false
        centerAboutIcon()
        val anim = FolderAnimationManager(this, true).animator
        anim.addListener(object : AnimatorListenerAdapter() {
            override fun onAnimationStart(animation: Animator) {
                folderIcon.setBackgroundVisible(false)
                folderIcon.drawLeaveBehindIfExists()
            }

            override fun onAnimationEnd(animation: Animator) {
                state = STATE_OPEN
                announceAccessibilityChanges()
                launcher.userEventDispatcher.resetElapsedContainerMillis("folder opened")
                content.setFocusOnFirstChild()
            }
        })

        // Footer animation
        if (content.pageCount > 1 && !info.hasOption(FolderInfo.FLAG_MULTI_PAGE_ANIMATION)) {
            val footerWidth = (content.desiredWidth
                    - footer.paddingLeft - footer.paddingRight)
            val textWidth = name.paint.measureText(name.text.toString())
            val translation = (footerWidth - textWidth) / 2
            name.translationX = if (content.isRtl) -translation else translation
            pageIndicator.prepareEntryAnimation()

            // Do not update the flag if we are in drag mode. The flag will be updated, when we
            // actually drop the icon.
            val updateAnimationFlag = !dragInProgress
            anim.addListener(object : AnimatorListenerAdapter() {
                @SuppressLint("InlinedApi")
                override fun onAnimationEnd(animation: Animator) {
                    name.animate().setDuration(FOLDER_NAME_ANIMATION_DURATION)
                            .translationX(0f).interpolator = AnimationUtils.loadInterpolator(
                            launcher, android.R.interpolator.fast_out_slow_in)
                    pageIndicator.playEntryAnimation()
                    if (updateAnimationFlag) {
                        info.setOption(FolderInfo.FLAG_MULTI_PAGE_ANIMATION, true,
                                launcher.modelWriter)
                    }
                }
            })
        } else {
            name.translationX = 0f
        }
        pageIndicator.stopAllAnimations()
        startAnimation(anim)

        // Make sure the folder picks up the last drag move even if the finger doesn't move.
        if (dragController.isDragging) {
            dragController.forceTouchMove()
        }
        content.verifyVisibleHighResIcons(content.nextPage)
    }

    fun beginExternalDrag() {
        emptyCellRank = content.allocateRankForNewItem()
        isExternalDrag = true
        dragInProgress = true

        // Since this folder opened by another controller, it might not get onDrop or
        // onDropComplete. Perform cleanup once drag-n-drop ends.
        dragController.addDragListener(this)
    }

    override fun isOfType(type: Int): Boolean {
        return type and TYPE_FOLDER != 0
    }

    override fun handleClose(animate: Boolean) {
        isOpen = false
        if (isEditingName) {
            name.dispatchBackKey()
        }
        folderIcon.clearLeaveBehindIfExists()
        if (animate) {
            animateClosed()
        } else {
            closeComplete(false)
            post { announceAccessibilityChanges() }
        }

        // Notify the accessibility manager that this folder "window" has disappeared and no
        // longer occludes the workspace items
        launcher.dragLayer.sendAccessibilityEvent(
                AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED)
    }

    private fun animateClosed() {
        val a = FolderAnimationManager(this, false /* isOpening */).animator
        a.addListener(object : AnimatorListenerAdapter() {
            override fun onAnimationEnd(animation: Animator) {
                closeComplete(true)
                announceAccessibilityChanges()
            }
        })
        startAnimation(a)
    }

    override fun getAccessibilityTarget(): Pair<View, String> {
        return Pair.create(content, if (isOpen) content!!.accessibilityDescription else context.getString(R.string.folder_closed))
    }

    private fun closeComplete(wasAnimated: Boolean) {
        // TODO: Clear all active animations.
        val parent = parent as? DragLayer
        parent?.removeView(this)
        dragController.removeDropTarget(this)
        clearFocus()
        with (folderIcon) {
            visibility = VISIBLE
            setBackgroundVisible(true)
            getName().setTextVisibility(true)
            if (wasAnimated) {
                background.fadeInBackgroundShadow()
                background.animateBackgroundStroke()
                content?.apply {
                    onFolderClose(currentPage)
                }
                if (hasBadge()) {
                    createBadgeScaleAnimator(0f, 1f).start()
                }
                requestFocus()
            }
        }
        if (rearrangeOnClose) {
            rearrangeChildren()
            rearrangeOnClose = false
        }
        if (itemCount <= 1) {
            if (!dragInProgress && !suppressFolderDeletion) {
                replaceFolderWithFinalItem()
            } else if (dragInProgress) {
                deleteFolderOnDropCompleted = true
            }
        }
        suppressFolderDeletion = false
        clearDragInfo()
        state = STATE_SMALL
        content?.currentPage = 0
    }

    override fun acceptDrop(d: DragObject): Boolean {
        val item = d.dragInfo
        val itemType = item.itemType
        return itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION
                || itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT
                || itemType == LauncherSettings.Favorites.ITEM_TYPE_DEEP_SHORTCUT
    }

    override fun onDragEnter(d: DragObject) {
        prevTargetRank = -1
        onExitAlarm.cancelAlarm()
        // Get the area offset such that the folder only closes if half the drag icon width
        // is outside the folder area
        scrollAreaOffset = d.dragView.dragRegionWidth / 2 - d.xOffset
    }

    private fun getTargetRank(d: DragObject, recycle: FloatArray?): Int {
        var recycle = recycle
        recycle = d.getVisualCenter(recycle)
        return content.findNearestArea(
                recycle[0].toInt() - paddingLeft, recycle[1].toInt() - paddingTop)
    }

    fun getContent() = content!!

    override fun onDragOver(d: DragObject) {
        if (scrollPauseAlarm.alarmPending()) return
        val r = FloatArray(2)
        targetRank = getTargetRank(d, r)
        if (targetRank != prevTargetRank) {
            reorderAlarm.cancelAlarm()
            reorderAlarm.setOnAlarmListener(reorderAlarmListener)
            reorderAlarm.setAlarm(REORDER_DELAY)
            prevTargetRank = targetRank
            d.stateAnnouncer?.announce(context.getString(R.string.move_to_position,
                        targetRank + 1))
        }
        val x = r[0]
        val currentPage = content.nextPage
        val cellOverlap = (content.currentCellLayout.cellWidth * ICON_OVERSCROLL_WIDTH_FACTOR)
        val isOutsideLeftEdge = x < cellOverlap
        val isOutsideRightEdge = x > width - cellOverlap
        if (currentPage > 0 && (if (content.isRtl) isOutsideRightEdge else isOutsideLeftEdge)) {
            showScrollHint(SCROLL_LEFT, d)
        } else if (currentPage < content.pageCount - 1
                && if (content.isRtl) isOutsideLeftEdge else isOutsideRightEdge) {
            showScrollHint(SCROLL_RIGHT, d)
        } else {
            onScrollHintAlarm.cancelAlarm()
            if (scrollHintDir != SCROLL_NONE) {
                content.clearScrollHint()
                scrollHintDir = SCROLL_NONE
            }
        }
    }

    private fun showScrollHint(direction: Int, d: DragObject) {
        // Show scroll hint on the right
        if (scrollHintDir != direction) {
            content.showScrollHint(direction)
            scrollHintDir = direction
        }

        // Set alarm for when the hint is complete
        if (!onScrollHintAlarm.alarmPending() || currentScrollDir != direction) {
            currentScrollDir = direction
            onScrollHintAlarm.cancelAlarm()
            onScrollHintAlarm.setOnAlarmListener(OnScrollHintListener(d))
            onScrollHintAlarm.setAlarm(SCROLL_HINT_DURATION)
            reorderAlarm.cancelAlarm()
            targetRank = emptyCellRank
        }
    }

    fun completeDragExit() {
        when {
            isOpen -> {
                close(true)
                rearrangeOnClose = true
            }
            state == STATE_ANIMATING -> {
                rearrangeOnClose = true
            }
            else -> {
                rearrangeChildren()
                clearDragInfo()
            }
        }
    }

    private fun clearDragInfo() {
        currentDragView = null
        isExternalDrag = false
    }

    override fun onDragExit(d: DragObject) {
        // We only close the folder if this is a true drag exit, ie. not because
        // a drop has occurred above the folder.
        if (!d.dragComplete) {
            onExitAlarm.setOnAlarmListener(onExitAlarmListener)
            onExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY)
        }
        reorderAlarm.cancelAlarm()
        onScrollHintAlarm.cancelAlarm()
        scrollPauseAlarm.cancelAlarm()
        if (scrollHintDir != SCROLL_NONE) {
            content.clearScrollHint()
            scrollHintDir = SCROLL_NONE
        }
    }

    /**
     * When performing an accessibility drop, onDrop is sent immediately after onDragEnter. So we
     * need to complete all transient states based on timers.
     */
    override fun prepareAccessibilityDrop() {
        if (reorderAlarm.alarmPending()) {
            reorderAlarm.cancelAlarm()
            reorderAlarmListener.onAlarm(reorderAlarm)
        }
    }

    override fun onDropCompleted(target: View, d: DragObject,
                                 success: Boolean) {
        if (success) {
            if (deleteFolderOnDropCompleted && !itemAddedBackToSelfViaIcon && target !== this) {
                replaceFolderWithFinalItem()
            }
        } else {
            // The drag failed, we need to return the item to the folder
            val info = d.dragInfo as ShortcutInfo
            val icon = if (currentDragView?.tag === info) currentDragView!! else content.createNewView(info)
            val views = itemsInReadingOrder
            views.add(info.rank, icon)
            content.arrangeChildren(views, views.size)
            itemsInvalidated = true
            SuppressInfoChanges().use { folderIcon.onDrop(d, true) }
        }
        if (target !== this) {
            if (onExitAlarm.alarmPending()) {
                onExitAlarm.cancelAlarm()
                if (!success) {
                    suppressFolderDeletion = true
                }
                scrollPauseAlarm.cancelAlarm()
                completeDragExit()
            }
        }
        deleteFolderOnDropCompleted = false
        dragInProgress = false
        itemAddedBackToSelfViaIcon = false
        currentDragView = null

        // Reordering may have occured, and we need to save the new item locations. We do this once
        // at the end to prevent unnecessary database operations.
        updateItemLocationsInDatabaseBatch()

        // Use the item count to check for multi-page as the folder UI may not have
        // been refreshed yet.
        if (itemCount <= content.itemsPerPage()) {
            // Show the animation, next time something is added to the folder.
            info.setOption(FolderInfo.FLAG_MULTI_PAGE_ANIMATION, false,
                    launcher.modelWriter)
        }
    }

    private fun updateItemLocationsInDatabaseBatch() {
        val list = itemsInReadingOrder
        val items = ArrayList<ItemInfo>()
        for (i in list.indices) {
            val v = list[i]
            val info = v.tag as ItemInfo
            info.rank = i
            items.add(info)
        }
        launcher.modelWriter.moveItemsInDatabase(items, info.id, 0)
    }

    fun notifyDrop() {
        if (dragInProgress) {
            itemAddedBackToSelfViaIcon = true
        }
    }

    override fun isDropEnabled() = state != STATE_ANIMATING

    private fun centerAboutIcon() {
        val grid = launcher.deviceProfile
        val lp = layoutParams as BaseDragLayerLayoutParams
        val parent = launcher.findViewById<View>(R.id.drag_layer) as DragLayer
        val width = folderWidth
        val height = folderHeight
        parent.getDescendantRectRelativeToSelf(folderIcon, sTempRect)
        val centerX = sTempRect.centerX()
        val centerY = sTempRect.centerY()
        val centeredLeft = centerX - width / 2
        val centeredTop = centerY - height / 2

        // We need to bound the folder to the currently visible workspace area
        if (launcher.stateManager.state.overviewUi) {
            launcher.dragLayer.getDescendantRectRelativeToSelf(launcher.getOverviewPanel(),
                    sTempRect)
        } else {
            launcher.workspace.getPageAreaRelativeToDragLayer(sTempRect)
        }
        var left = min(max(sTempRect.left, centeredLeft), sTempRect.right - width)
        var top = min(max(sTempRect.top, centeredTop), sTempRect.bottom - height)
        val distFromEdgeOfScreen = launcher.workspace.paddingLeft + paddingLeft
        if (grid.isPhone && grid.availableWidthPx - width < 4 * distFromEdgeOfScreen) {
            // Center the folder if it is very close to being centered anyway, by virtue of
            // filling the majority of the viewport. ie. remove it from the uncanny valley
            // of centeredness.
            left = (grid.availableWidthPx - width) / 2
        } else if (width >= sTempRect.width()) {
            // If the folder doesn't fit within the bounds, center it about the desired bounds
            left = sTempRect.left + (sTempRect.width() - width) / 2
        }
        if (height >= sTempRect.height()) {
            // Folder height is greater than page height, center on page
            top = sTempRect.top + (sTempRect.height() - height) / 2
        } else {
            // Folder height is less than page height, so bound it to the absolute open folder
            // bounds if necessary
            val folderBounds = grid.absoluteOpenFolderBounds
            left = max(folderBounds.left, min(left, folderBounds.right - width))
            top = max(folderBounds.top, min(top, folderBounds.bottom - height))
        }
        val folderPivotX = width / 2 + (centeredLeft - left)
        val folderPivotY = height / 2 + (centeredTop - top)
        pivotX = folderPivotX.toFloat()
        pivotY = folderPivotY.toFloat()
        pivotXForIconAnimation = (folderIcon.measuredWidth * (1.0f * folderPivotX / width))
        pivotYForIconAnimation = (folderIcon.measuredHeight * (1.0f * folderPivotY / height))
        lp.width = width
        lp.height = height
        lp.x = left
        lp.y = top
    }

    private fun getFolderHeight(contentAreaHeight: Int) = paddingTop + paddingBottom + contentAreaHeight + footerHeight

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        val contentWidth = contentAreaWidth
        val contentHeight = contentAreaHeight
        val contentAreaWidthSpec = MeasureSpec.makeMeasureSpec(contentWidth, MeasureSpec.EXACTLY)
        val contentAreaHeightSpec = MeasureSpec.makeMeasureSpec(contentHeight, MeasureSpec.EXACTLY)
        content.setFixedSize(contentWidth, contentHeight)
        content.measure(contentAreaWidthSpec, contentAreaHeightSpec)
        if (content.childCount > 0) {
            val cellIconGap = (content.getPageAt(0).cellWidth
                    - launcher.deviceProfile.iconSizePx) / 2
            footer.setPadding(content.paddingLeft + cellIconGap,
                    footer.paddingTop,
                    content.paddingRight + cellIconGap,
                    footer.paddingBottom)
        }
        footer.measure(contentAreaWidthSpec,
                MeasureSpec.makeMeasureSpec(footerHeight, MeasureSpec.EXACTLY))
        val folderWidth = paddingLeft + paddingRight + contentWidth
        val folderHeight = getFolderHeight(contentHeight)
        setMeasuredDimension(folderWidth, folderHeight)
    }
    /**
     * Rearranges the children based on their rank.
     * @param itemCount if greater than the total children count, empty spaces are left at the end,
     * otherwise it is ignored.
     */
    /**
     * Rearranges the children based on their rank.
     */
    @JvmOverloads
    fun rearrangeChildren(itemCount: Int = -1) {
        val views = itemsInReadingOrder
        content.arrangeChildren(views, max(itemCount, views.size))
        itemsInvalidated = true
    }

    @Thunk
    fun replaceFolderWithFinalItem() {
        // Add the last remaining child to the workspace in place of the folder
        val onCompleteRunnable = Runnable {
            val itemCount = info.contents.size
            if (itemCount <= 1) {
                var newIcon: View? = null
                if (itemCount == 1) {
                    // Move the item from the folder to the workspace, in the position of the
                    // folder
                    val cellLayout = launcher.getCellLayout(info.container,
                            info.screenId)
                    val finalItem = info.contents.removeAt(0)
                    newIcon = launcher.createShortcut(cellLayout, finalItem)
                    launcher.modelWriter.addOrMoveItemInDatabase(finalItem,
                            info.container, info.screenId, info.cellX, info.cellY)
                }

                // Remove the folder
                launcher.removeItem(folderIcon, info, true)
//                if (folderIcon is DropTarget) {
//                    dragController.removeDropTarget(folderIcon as DropTarget?)
//                }
                if (newIcon != null) {
                    // We add the child after removing the folder to prevent both from existing
                    // at the same time in the CellLayout.  We need to add the new item with
                    // addInScreenFromBind() to ensure that hotseat items are placed correctly.
                    launcher.workspace.addInScreenFromBind(newIcon, info)

                    // Focus the newly created child
                    newIcon.requestFocus()
                }
            }
        }
        val finalChild = content.lastItem
        if (finalChild != null) {
            folderIcon.performDestroyAnimation(onCompleteRunnable)
        } else {
            onCompleteRunnable.run()
        }
        isDestroyed = true
    }

    // This method keeps track of the first and last item in the folder for the purposes
    // of keyboard focus
    fun updateTextViewFocus() {
        val firstChild = content.firstItem
        val lastChild = content.lastItem
        if (firstChild != null && lastChild != null) {
            name.nextFocusDownId = lastChild.id
            name.nextFocusRightId = lastChild.id
            name.nextFocusLeftId = lastChild.id
            name.nextFocusUpId = lastChild.id
            // Hitting TAB from the folder name wraps around to the first item on the current
            // folder page, and hitting SHIFT+TAB from that item wraps back to the folder name.
            name.nextFocusForwardId = firstChild.id
            // When clicking off the folder when editing the name, this Folder gains focus. When
            // pressing an arrow key from that state, give the focus to the first item.
            this.nextFocusDownId = firstChild.id
            this.nextFocusRightId = firstChild.id
            this.nextFocusLeftId = firstChild.id
            this.nextFocusUpId = firstChild.id
            // When pressing shift+tab in the above state, give the focus to the last item.
            setOnKeyListener { _, keyCode, event ->
                val isShiftPlusTab = keyCode == KeyEvent.KEYCODE_TAB &&
                        event.hasModifiers(KeyEvent.META_SHIFT_ON)
                if (isShiftPlusTab && this@Folder.isFocused) {
                    lastChild.requestFocus()
                } else false
            }
        }
    }

    override fun onDrop(d: DragObject, options: DragOptions) {
        // If the icon was dropped while the page was being scrolled, we need to compute
        // the target location again such that the icon is placed of the final page.
        if (!content.rankOnCurrentPage(emptyCellRank)) {
            // Reorder again.
            targetRank = getTargetRank(d, null)

            // Rearrange items immediately.
            reorderAlarmListener.onAlarm(reorderAlarm)
            onScrollHintAlarm.cancelAlarm()
            scrollPauseAlarm.cancelAlarm()
        }
        content.completePendingPageChanges()
        val pasi = if (d.dragInfo is PendingAddShortcutInfo) d.dragInfo as PendingAddShortcutInfo else null
        val pasiSi = pasi?.activityInfo?.createShortcutInfo()
        if (pasi != null && pasiSi == null) {
            // There is no ShortcutInfo, so we have to go through a configuration activity.
            pasi.container = info.id
            pasi.rank = emptyCellRank
            launcher.addPendingItem(pasi, pasi.container, pasi.screenId, null, pasi.spanX,
                    pasi.spanY)
            d.deferDragViewCleanupPostAnimation = false
            rearrangeOnClose = true
        } else {
            val si = pasiSi
                    ?: if (d.dragInfo is AppInfo) {
                        // Came from all apps -- make a copy.
                        (d.dragInfo as AppInfo).makeShortcut()
                    } else {
                        // ShortcutInfo
                        d.dragInfo as ShortcutInfo
                    }
            val currentDragView: View?
            if (isExternalDrag) {
                currentDragView = content.createAndAddViewForRank(si, emptyCellRank)

                // Actually move the item in the database if it was an external drag. Call this
                // before creating the view, so that ShortcutInfo is updated appropriately.
                launcher.modelWriter.addOrMoveItemInDatabase(
                        si, info.id, 0, si.cellX, si.cellY)

                // We only need to update the locations if it doesn't get handled in
                // #onDropCompleted.
                if (d.dragSource !== this) {
                    updateItemLocationsInDatabaseBatch()
                }
                isExternalDrag = false
            } else {
                currentDragView = this.currentDragView
                content.addViewForRank(currentDragView!!, si, emptyCellRank)
            }
            if (d.dragView.hasDrawn()) {
                // Temporarily reset the scale such that the animation target gets calculated
                // correctly.
                val scaleX = scaleX
                val scaleY = scaleY
                setScaleX(1.0f)
                setScaleY(1.0f)
                launcher.dragLayer.animateViewIntoPosition(d.dragView, currentDragView, null)
                setScaleX(scaleX)
                setScaleY(scaleY)
            } else {
                d.deferDragViewCleanupPostAnimation = false
                currentDragView.visibility = VISIBLE
            }
            itemsInvalidated = true
            rearrangeChildren()
            SuppressInfoChanges().use { info.add(si, false) }
        }

        // Clear the drag info, as it is no longer being dragged.
        dragInProgress = false
        if (content.pageCount > 1) {
            // The animation has already been shown while opening the folder.
            info.setOption(FolderInfo.FLAG_MULTI_PAGE_ANIMATION, true, launcher.modelWriter)
        }
        launcher.stateManager.goToState(LauncherState.NORMAL, LauncherAnimUtils.SPRING_LOADED_EXIT_DELAY.toLong())
        d.stateAnnouncer?.completeAction(R.string.item_moved)
    }

    // This is used so the item doesn't immediately appear in the folder when added. In one case
    // we need to create the illusion that the item isn't added back to the folder yet, to
    // to correspond to the animation of the icon back into the folder. This is
    fun hideItem(info: ShortcutInfo) {
        val v = getViewForInfo(info)
        v!!.visibility = INVISIBLE
    }

    fun showItem(info: ShortcutInfo) {
        val v = getViewForInfo(info)
        v!!.visibility = VISIBLE
    }

    override fun onAdd(item: ShortcutInfo, rank: Int) {
        val view = content.createAndAddViewForRank(item, rank)
        launcher.modelWriter.addOrMoveItemInDatabase(item, info.id, 0, item.cellX,
                item.cellY)
        val items = ArrayList(itemsInReadingOrder)
        items.add(rank, view)
        content.arrangeChildren(items, items.size)
        itemsInvalidated = true
    }

    override fun onRemove(item: ShortcutInfo) {
        itemsInvalidated = true
        val v = getViewForInfo(item)
        content.removeItem(v)
        if (state == STATE_ANIMATING) {
            rearrangeOnClose = true
        } else {
            rearrangeChildren()
        }
        if (itemCount <= 1) {
            if (isOpen) {
                close(true)
            } else {
                replaceFolderWithFinalItem()
            }
        }
    }

    private fun getViewForInfo(item: ShortcutInfo): View? {
        return content.iterateOverItems(ItemOperator { info, _ -> info === item })
    }

    override fun onItemsChanged(animate: Boolean) {
        updateTextViewFocus()
    }

    override fun prepareAutoUpdate() {
        close(false)
    }

    override fun onTitleChanged(title: CharSequence) = Unit

    fun getItemsOnPage(page: Int): List<BubbleTextView> {
        val allItems = itemsInReadingOrder
        val lastPage = content.pageCount - 1
        val totalItemsInFolder = allItems.size
        val itemsPerPage = content.itemsPerPage()
        val numItemsOnCurrentPage = if (page == lastPage) totalItemsInFolder - itemsPerPage * page else itemsPerPage
        val startIndex = page * itemsPerPage
        val endIndex = min(startIndex + numItemsOnCurrentPage, allItems.size)
        val itemsOnCurrentPage: MutableList<BubbleTextView> = ArrayList(numItemsOnCurrentPage)
        for (i in startIndex until endIndex) {
            itemsOnCurrentPage.add(allItems[i] as BubbleTextView)
        }
        return itemsOnCurrentPage
    }

    override fun onFocusChange(v: View, hasFocus: Boolean) {
        if (v === name) {
            if (hasFocus) {
                startEditingFolderName()
            } else {
                name.dispatchBackKey()
            }
        }
    }

    override fun getHitRectRelativeToDragLayer(outRect: Rect) {
        getHitRect(outRect)
        outRect.left -= scrollAreaOffset
        outRect.right += scrollAreaOffset
    }

    override fun fillInLogContainerData(v: View?, info: ItemInfo, target: LauncherLogProto.Target, targetParent: LauncherLogProto.Target) {
        target.gridX = info.cellX
        target.gridY = info.cellY
        target.pageIndex = content.currentPage
        targetParent.containerType = LauncherLogProto.ContainerType.FOLDER
    }

    private inner class OnScrollHintListener constructor(private val dragObject: DragObject) : OnAlarmListener {
        /**
         * Scroll hint has been shown long enough. Now scroll to appropriate page.
         */
        override fun onAlarm(alarm: Alarm) {
            scrollHintDir = when (currentScrollDir) {
                SCROLL_LEFT -> {
                    content.scrollLeft()
                    SCROLL_NONE
                }
                SCROLL_RIGHT -> {
                    content.scrollRight()
                    SCROLL_NONE
                }
                else -> {
                    // This should not happen
                    return
                }
            }
            currentScrollDir = SCROLL_NONE

            // Pause drag event until the scrolling is finished
            scrollPauseAlarm.setOnAlarmListener(OnScrollFinishedListener(dragObject))
            scrollPauseAlarm.setAlarm(RESCROLL_DELAY.toLong())
        }
    }

    private inner class OnScrollFinishedListener constructor(private val dragObject: DragObject) : OnAlarmListener {
        /**
         * Page scroll is complete.
         */
        override fun onAlarm(alarm: Alarm) {
            // Reorder immediately on page change.
            onDragOver(dragObject)
        }
    }

    /**
     * Temporary resource held while we don't want to handle info changes
     */
    private inner class SuppressInfoChanges : AutoCloseable {
        override fun close() {
            info.addListener(this@Folder)
            updateTextViewFocus()
        }

        init {
            info.removeListener(this@Folder)
        }
    }

    override fun logActionCommand(command: Int) {
        launcher.userEventDispatcher.logActionCommand(
                command, folderIcon, LauncherLogProto.ContainerType.FOLDER)
    }

    override fun onBackPressed(): Boolean {
        if (isEditingName) {
            name.dispatchBackKey()
        } else {
            super.onBackPressed()
        }
        return true
    }

    override fun onControllerInterceptTouchEvent(ev: MotionEvent): Boolean {
        if (ev.action == MotionEvent.ACTION_DOWN) {
            val dl = launcher.dragLayer
            if (isEditingName) {
                if (!dl.isEventOverView(name, ev)) {
                    name.dispatchBackKey()
                    return true
                }
                return false
            } else if (!dl.isEventOverView(this, ev)) {
                if (launcher.accessibilityDelegate.isInAccessibleDrag) {
                    // Do not close the container if in drag and drop.
                    if (!dl.isEventOverView(launcher.dropTargetBar, ev)) {
                        return true
                    }
                } else {
                    launcher.userEventDispatcher.logActionTapOutside(
                            newContainerTarget(LauncherLogProto.ContainerType.FOLDER))
                    close(true)
                    return true
                }
            }
        }
        return false
    }

    private fun setupName() {
        name.setOnBackKeyListener(this)
        name.onFocusChangeListener = this
        if (!Utilities.ATLEAST_MARSHMALLOW) {
            // We disable action mode in older OSes where floating selection menu is not yet available.
            name.customSelectionActionModeCallback = object : ActionMode.Callback {
                override fun onActionItemClicked(mode: ActionMode, item: MenuItem) = false
                override fun onCreateActionMode(mode: ActionMode, menu: Menu) = false
                override fun onDestroyActionMode(mode: ActionMode) = Unit
                override fun onPrepareActionMode(mode: ActionMode, menu: Menu) = false
            }
        }
        name.setOnEditorActionListener(this)
        name.setSelectAllOnFocus(true)
        name.inputType = ((name.inputType
                and InputType.TYPE_TEXT_FLAG_AUTO_CORRECT.inv()
                and InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS.inv())
                or InputType.TYPE_TEXT_FLAG_CAP_WORDS)
        name.forceDisableSuggestions(true)
    }

    fun getName() = name!!

    companion object {
        private const val TAG = "Launcher.Folder"

        /**
         * We avoid measuring [.mContent] with a 0 width or height, as this
         * results in CellLayout being measured as UNSPECIFIED, which it does not support.
         */
        private const val MIN_CONTENT_DIMEN = 5
        const val STATE_NONE = -1
        const val STATE_SMALL = 0
        const val STATE_ANIMATING = 1
        const val STATE_OPEN = 2

        /**
         * Time for which the scroll hint is shown before automatically changing page.
         */
        const val SCROLL_HINT_DURATION = 500L
        const val RESCROLL_DELAY = PagedView.PAGE_SNAP_ANIMATION_DURATION + 150
        const val SCROLL_NONE = -1
        const val SCROLL_LEFT = 0
        const val SCROLL_RIGHT = 1

        /**
         * Fraction of icon width which behave as scroll region.
         */
        private const val ICON_OVERSCROLL_WIDTH_FACTOR = 0.45f
        private const val FOLDER_NAME_ANIMATION_DURATION = 633L
        private const val REORDER_DELAY = 250L
        private const val ON_EXIT_CLOSE_DELAY = 400L
        private val sTempRect = Rect()
        private var sDefaultFolderName: String? = null
        private var sHintText: String? = null

        /**
         * Creates a new UserFolder, inflated from R.layout.user_folder.
         *
         * @param launcher The main activity.
         *
         * @return A new UserFolder.
         */
        @SuppressLint("InflateParams")
        fun fromXml(launcher: Launcher): Folder {
            return launcher.layoutInflater
                    .inflate(R.layout.user_folder_icon_normalized, null) as Folder
        }

        // Compares item position based on rank and position giving priority to the rank.
        @JvmField
        val ITEM_POS_COMPARATOR = Comparator<ItemInfo> { lhs, rhs ->
            when {
                lhs.rank != rhs.rank -> {
                    lhs.rank - rhs.rank
                }
                lhs.cellY != rhs.cellY -> {
                    lhs.cellY - rhs.cellY
                }
                else -> {
                    lhs.cellX - rhs.cellX
                }
            }
        }

        /**
         * Returns a folder which is already open or null
         */
        @JvmStatic
        fun getOpen(launcher: Launcher): Folder? {
            return getOpenView(launcher, TYPE_FOLDER)
        }
    }
}